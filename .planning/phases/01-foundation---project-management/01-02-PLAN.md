---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/dal.ts
  - src/lib/validations/auth.ts
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/signup/page.tsx
  - src/app/(auth)/layout.tsx
  - src/actions/auth.ts
  - src/app/(auth)/auth/confirm/route.ts
autonomous: true

must_haves:
  truths:
    - "User can sign up with email and password"
    - "User can log in with valid credentials"
    - "Invalid credentials show error message"
    - "Authenticated user is redirected to dashboard"
    - "Unauthenticated user accessing protected routes is redirected to login"
  artifacts:
    - path: "src/lib/dal.ts"
      provides: "Data Access Layer with session verification"
      contains: "verifySession"
    - path: "src/app/(auth)/login/page.tsx"
      provides: "Login page UI"
      min_lines: 30
    - path: "src/app/(auth)/signup/page.tsx"
      provides: "Signup page UI"
      min_lines: 30
    - path: "src/actions/auth.ts"
      provides: "Server Actions for auth"
      contains: "'use server'"
  key_links:
    - from: "src/actions/auth.ts"
      to: "src/lib/supabase/server.ts"
      via: "Supabase client for auth operations"
      pattern: "createClient.*auth\\."
    - from: "src/lib/dal.ts"
      to: "src/lib/supabase/server.ts"
      via: "Session verification"
      pattern: "getUser"
---

<objective>
Implement user authentication with Supabase Auth.

Purpose: Enable user sign-up and login so that projects can be associated with specific users and RLS policies can enforce data isolation.

Output: Working authentication flow with login/signup pages, Server Actions for auth operations, and a Data Access Layer for session verification.
</objective>

<execution_context>
@/home/thomas/.claude/get-shit-done/workflows/execute-plan.md
@/home/thomas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation---project-management/01-RESEARCH.md
@.planning/phases/01-foundation---project-management/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Data Access Layer and validation schemas</name>
  <files>
    src/lib/dal.ts
    src/lib/validations/auth.ts
  </files>
  <action>
Create the Data Access Layer **src/lib/dal.ts**:
```typescript
import 'server-only'
import { cache } from 'react'
import { redirect } from 'next/navigation'
import { createClient } from '@/lib/supabase/server'

export const verifySession = cache(async () => {
  const supabase = await createClient()
  const { data: { user }, error } = await supabase.auth.getUser()

  if (!user || error) {
    redirect('/login')
  }

  return { isAuth: true, userId: user.id, email: user.email }
})

export const getOptionalSession = cache(async () => {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) {
    return null
  }

  return { userId: user.id, email: user.email }
})
```

Install server-only package:
```bash
npm install server-only
```

Create validation schemas **src/lib/validations/auth.ts**:
```typescript
import { z } from 'zod'

export const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
})

export const signupSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ['confirmPassword'],
})

export type LoginInput = z.infer<typeof loginSchema>
export type SignupInput = z.infer<typeof signupSchema>
```
  </action>
  <verify>
Files exist: src/lib/dal.ts, src/lib/validations/auth.ts
`npx tsc --noEmit` passes without errors.
`npm ls server-only` shows package installed.
  </verify>
  <done>
Data Access Layer created with cached session verification. Zod schemas defined for login and signup validation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth Server Actions</name>
  <files>
    src/actions/auth.ts
    src/app/(auth)/auth/confirm/route.ts
  </files>
  <action>
Create auth Server Actions **src/actions/auth.ts**:
```typescript
'use server'

import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'
import { createClient } from '@/lib/supabase/server'
import { loginSchema, signupSchema } from '@/lib/validations/auth'

export type AuthState = {
  errors?: {
    email?: string[]
    password?: string[]
    confirmPassword?: string[]
    _form?: string[]
  }
  message?: string
}

export async function login(prevState: AuthState, formData: FormData): Promise<AuthState> {
  const supabase = await createClient()

  const validated = loginSchema.safeParse({
    email: formData.get('email'),
    password: formData.get('password'),
  })

  if (!validated.success) {
    return {
      errors: validated.error.flatten().fieldErrors,
    }
  }

  const { error } = await supabase.auth.signInWithPassword(validated.data)

  if (error) {
    return {
      errors: {
        _form: [error.message],
      },
    }
  }

  revalidatePath('/', 'layout')
  redirect('/dashboard')
}

export async function signup(prevState: AuthState, formData: FormData): Promise<AuthState> {
  const supabase = await createClient()

  const validated = signupSchema.safeParse({
    email: formData.get('email'),
    password: formData.get('password'),
    confirmPassword: formData.get('confirmPassword'),
  })

  if (!validated.success) {
    return {
      errors: validated.error.flatten().fieldErrors,
    }
  }

  const { error } = await supabase.auth.signUp({
    email: validated.data.email,
    password: validated.data.password,
    options: {
      emailRedirectTo: `${process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'}/auth/confirm`,
    },
  })

  if (error) {
    return {
      errors: {
        _form: [error.message],
      },
    }
  }

  return {
    message: 'Check your email for a confirmation link.',
  }
}

export async function logout() {
  const supabase = await createClient()
  await supabase.auth.signOut()
  revalidatePath('/', 'layout')
  redirect('/login')
}
```

Create email confirmation route **src/app/(auth)/auth/confirm/route.ts**:
```typescript
import { type EmailOtpType } from '@supabase/supabase-js'
import { type NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const token_hash = searchParams.get('token_hash')
  const type = searchParams.get('type') as EmailOtpType | null
  const next = searchParams.get('next') ?? '/dashboard'

  const redirectTo = request.nextUrl.clone()
  redirectTo.pathname = next
  redirectTo.searchParams.delete('token_hash')
  redirectTo.searchParams.delete('type')

  if (token_hash && type) {
    const supabase = await createClient()

    const { error } = await supabase.auth.verifyOtp({
      type,
      token_hash,
    })

    if (!error) {
      redirectTo.searchParams.delete('next')
      return NextResponse.redirect(redirectTo)
    }
  }

  // Return to login with error
  redirectTo.pathname = '/login'
  redirectTo.searchParams.set('error', 'Could not verify email')
  return NextResponse.redirect(redirectTo)
}
```
  </action>
  <verify>
Files exist: src/actions/auth.ts, src/app/(auth)/auth/confirm/route.ts
`npx tsc --noEmit` passes without errors.
auth.ts contains 'use server' directive.
  </verify>
  <done>
Server Actions created for login, signup, and logout. Email confirmation route handles Supabase email verification flow.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create auth UI pages</name>
  <files>
    src/app/(auth)/layout.tsx
    src/app/(auth)/login/page.tsx
    src/app/(auth)/signup/page.tsx
  </files>
  <action>
Create auth layout **src/app/(auth)/layout.tsx**:
```typescript
export default function AuthLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        {children}
      </div>
    </div>
  )
}
```

Create login page **src/app/(auth)/login/page.tsx**:
```typescript
'use client'

import { useActionState } from 'react'
import Link from 'next/link'
import { login, type AuthState } from '@/actions/auth'

const initialState: AuthState = {}

export default function LoginPage() {
  const [state, formAction, pending] = useActionState(login, initialState)

  return (
    <>
      <div>
        <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
          Sign in to your account
        </h2>
        <p className="mt-2 text-center text-sm text-gray-600">
          Or{' '}
          <Link href="/signup" className="font-medium text-indigo-600 hover:text-indigo-500">
            create a new account
          </Link>
        </p>
      </div>
      <form className="mt-8 space-y-6" action={formAction}>
        {state.errors?._form && (
          <div className="rounded-md bg-red-50 p-4">
            <p className="text-sm text-red-700">{state.errors._form[0]}</p>
          </div>
        )}
        <div className="rounded-md shadow-sm -space-y-px">
          <div>
            <label htmlFor="email" className="sr-only">
              Email address
            </label>
            <input
              id="email"
              name="email"
              type="email"
              autoComplete="email"
              required
              className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
              placeholder="Email address"
            />
            {state.errors?.email && (
              <p className="mt-1 text-sm text-red-600">{state.errors.email[0]}</p>
            )}
          </div>
          <div>
            <label htmlFor="password" className="sr-only">
              Password
            </label>
            <input
              id="password"
              name="password"
              type="password"
              autoComplete="current-password"
              required
              className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
              placeholder="Password"
            />
            {state.errors?.password && (
              <p className="mt-1 text-sm text-red-600">{state.errors.password[0]}</p>
            )}
          </div>
        </div>

        <div>
          <button
            type="submit"
            disabled={pending}
            className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
          >
            {pending ? 'Signing in...' : 'Sign in'}
          </button>
        </div>
      </form>
    </>
  )
}
```

Create signup page **src/app/(auth)/signup/page.tsx**:
```typescript
'use client'

import { useActionState } from 'react'
import Link from 'next/link'
import { signup, type AuthState } from '@/actions/auth'

const initialState: AuthState = {}

export default function SignupPage() {
  const [state, formAction, pending] = useActionState(signup, initialState)

  return (
    <>
      <div>
        <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
          Create your account
        </h2>
        <p className="mt-2 text-center text-sm text-gray-600">
          Or{' '}
          <Link href="/login" className="font-medium text-indigo-600 hover:text-indigo-500">
            sign in to existing account
          </Link>
        </p>
      </div>

      {state.message && (
        <div className="rounded-md bg-green-50 p-4">
          <p className="text-sm text-green-700">{state.message}</p>
        </div>
      )}

      <form className="mt-8 space-y-6" action={formAction}>
        {state.errors?._form && (
          <div className="rounded-md bg-red-50 p-4">
            <p className="text-sm text-red-700">{state.errors._form[0]}</p>
          </div>
        )}
        <div className="rounded-md shadow-sm -space-y-px">
          <div>
            <label htmlFor="email" className="sr-only">
              Email address
            </label>
            <input
              id="email"
              name="email"
              type="email"
              autoComplete="email"
              required
              className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
              placeholder="Email address"
            />
            {state.errors?.email && (
              <p className="mt-1 text-sm text-red-600">{state.errors.email[0]}</p>
            )}
          </div>
          <div>
            <label htmlFor="password" className="sr-only">
              Password
            </label>
            <input
              id="password"
              name="password"
              type="password"
              autoComplete="new-password"
              required
              className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
              placeholder="Password"
            />
            {state.errors?.password && (
              <p className="mt-1 text-sm text-red-600">{state.errors.password[0]}</p>
            )}
          </div>
          <div>
            <label htmlFor="confirmPassword" className="sr-only">
              Confirm Password
            </label>
            <input
              id="confirmPassword"
              name="confirmPassword"
              type="password"
              autoComplete="new-password"
              required
              className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
              placeholder="Confirm password"
            />
            {state.errors?.confirmPassword && (
              <p className="mt-1 text-sm text-red-600">{state.errors.confirmPassword[0]}</p>
            )}
          </div>
        </div>

        <div>
          <button
            type="submit"
            disabled={pending}
            className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
          >
            {pending ? 'Creating account...' : 'Create account'}
          </button>
        </div>
      </form>
    </>
  )
}
```
  </action>
  <verify>
Files exist: src/app/(auth)/layout.tsx, src/app/(auth)/login/page.tsx, src/app/(auth)/signup/page.tsx
`npx tsc --noEmit` passes without errors.
`npm run dev` runs and http://localhost:3000/login shows login page.
http://localhost:3000/signup shows signup page.
  </verify>
  <done>
Auth UI pages created with forms that connect to Server Actions. Login and signup pages display correctly with validation error handling.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run dev` starts successfully
2. http://localhost:3000/login shows styled login form
3. http://localhost:3000/signup shows styled signup form
4. Forms have validation error display areas
5. `npx tsc --noEmit` shows no TypeScript errors
</verification>

<success_criteria>
1. Login page renders with email/password fields
2. Signup page renders with email/password/confirm fields
3. Server Actions exist for login, signup, logout
4. Data Access Layer provides verifySession function
5. Email confirmation route handles Supabase verification
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation---project-management/01-02-SUMMARY.md`
</output>
